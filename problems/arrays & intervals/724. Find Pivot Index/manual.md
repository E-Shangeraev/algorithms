## Решение

```typescript
function pivotIndex(nums: number[]): number {
  const px = [0];

  nums.reduce((acc, cur) => {
    const sum = acc + cur;

    px.push(sum);

    return sum;
  }, 0);

  const right = px.length - 1;

  for (let left = 0; left <= right; left++) {
    if (px[left] === px[right] - px[left + 1]) {
      return left;
    }
  }

  return -1;
}
```

**Оценка по времени:** O(n), где n - размер списка nums

**Оценка по памяти:** O(n), где n - размер списка nums

**Описание решения:**

Решение через префиксный массив

1. Заводим переменную для префиксного массива `px`, которой присваиваем массив с первым элементом 0

2. Наполняем префиксный массив

3. Заводим правый указатель `right`, который будет соответствовать последнему индексу префиксного массива

4. Проходимся циклом по массиву `px`, где индексом на каждой итерации будет левый указатель `left`

5. Возвращаем `left` при выполнении условия `px[left] === px[right] - px[left + 1]`

6. Если цикл завершился, значит массив не содержит pivot index и возвращаем -1
